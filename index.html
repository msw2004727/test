<script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Firestore specific imports are removed as game state is handled by backend
        // import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, serverTimestamp, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const heartRateEl = document.getElementById('heart-rate');
        const bloodPressureEl = document.getElementById('blood-pressure');
        const facialExpressionEl = document.getElementById('facial-expression');
        const bodyLanguageEl = document.getElementById('body-language');
        const voiceToneEl = document.getElementById('voice-tone');
        const suspectStatusNameEl = document.getElementById('suspect-status-name');
        const suspectNameModalEl = document.getElementById('suspect-name-modal');
        const dobModalEl = document.getElementById('dob-modal');
        const zodiacModalEl = document.getElementById('zodiac-modal');
        const bloodTypeModalEl = document.getElementById('blood-type-modal');
        const ageModalEl = document.getElementById('age-modal');
        const genderModalEl = document.getElementById('gender-modal');
        const educationModalEl = document.getElementById('education-modal');
        const birthplaceModalEl = document.getElementById('birthplace-modal');
        const occupationModalEl = document.getElementById('occupation-modal');
        const healthStatusModalEl = document.getElementById('health-status-modal');
        const mannerismModalEl = document.getElementById('mannerism-modal');
        const personalityModalEl = document.getElementById('personality-modal');
        const autopsyReportModalContentEl = document.getElementById('autopsy-report-modal-content');
        const evidenceListModalContentEl = document.getElementById('evidence-list-modal-content');
        const doubtsListModalContentEl = document.getElementById('doubts-list-modal-content');
        const showPersonalDetailsButton = document.getElementById('show-personal-details-button');
        const showStorySummaryButton = document.getElementById('show-story-summary-button');
        const personalDetailsModal = document.getElementById('personal-details-modal');
        const storySummaryModal = document.getElementById('story-summary-modal');
        const dialogueAreaEl = document.getElementById('dialogue-area');
        const playerInputEl = document.getElementById('player-input');
        const sendButton = document.getElementById('send-button');
        const demandConfessionButton = document.getElementById('demand-confession-button');
        const toneButtons = document.querySelectorAll('.tone-button');
        const userIdDisplayEl = document.getElementById('user-id-display');
        const keywordModal = document.getElementById('keyword-modal');
        const keywordModalTitle = document.getElementById('keyword-modal-title');
        const keywordModalText = document.getElementById('keyword-modal-text');
        const keywordFolderLoaderEl = document.getElementById('keyword-folder-loader');
        const keywordFolderPagesBarEl = document.getElementById('keyword-folder-pages-bar');
        const keywordFolderPageTextEl = document.getElementById('keyword-folder-page-text');
        let keywordPageTimer = null;

        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverTitle = document.getElementById('game-over-title');
        const totalRoundsEl = document.getElementById('total-rounds');
        const gameAnalysisContainerEl = document.getElementById('game-analysis-container');
        const gameAnalysisTextEl = document.getElementById('game-analysis-text'); // Kept for fallback
        const achievementBannerEl = document.getElementById('achievement-banner');
        const achievementTitleEl = document.getElementById('achievement-title');
        const restartGameButton = document.getElementById('restart-game-button');
        const closeGameOverModalButton = document.getElementById('close-game-over-modal-button');
        const aiThinkingModal = document.getElementById('ai-thinking-modal'); // For API call loading
        const interrogationTipAreaEl = document.getElementById('interrogation-tip-area');
        const roundCountHeaderEl = document.getElementById('round-count-header');
        const confessionMeterTextCardEl = document.getElementById('confession-meter-text-card');
        const introModal = document.getElementById('intro-modal');
        const closeIntroModalButton = document.getElementById('close-intro-modal-button');
        const initialLoadingOverlay = document.getElementById('initial-loading-overlay');
        const initialLoadingMessageEl = document.getElementById('initial-loading-message'); // For initial game load
        const gameMainAreaEl = document.querySelector('.game-main-area');
        const backgroundMusicEl = document.getElementById('background-music');

        const firebaseConfig = typeof __firebase_config !== 'undefined'
            ? JSON.parse(__firebase_config)
            : {
                apiKey: "YOUR_OWN_FIREBASE_API_KEY",
                authDomain: "YOUR_OWN_FIREBASE_AUTH_DOMAIN",
                projectId: "YOUR_OWN_FIREBASE_PROJECT_ID",
                storageBucket: "YOUR_OWN_FIREBASE_STORAGE_BUCKET",
                messagingSenderId: "YOUR_OWN_FIREBASE_MESSAGING_SENDER_ID",
                appId: "YOUR_OWN_FIREBASE_APP_ID"
              };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        // setLogLevel('error'); // Firestore specific, can be removed or kept if other Firebase services are used.

        const BACKEND_URL = 'http://127.0.0.1:5001'; // Your Python backend URL

        let userId = null; // Firebase Auth User ID
        let currentGameId = null; // ID of the current game, obtained from backend
        let gameState = {}; // This will hold the game state received from the backend

        // Function to show a generic loading modal for API calls
        function showThinkingModal(message = 'AIæ­£åœ¨åŠªåŠ›æ€è€ƒä¸­...') {
            if(aiThinkingModal) {
                const thinkingText = aiThinkingModal.querySelector('p.text-lg');
                if(thinkingText) thinkingText.textContent = `ğŸ¤– ${message}`;
                aiThinkingModal.classList.remove('hidden');
            }
        }

        function hideThinkingModal() {
            if(aiThinkingModal) aiThinkingModal.classList.add('hidden');
        }
        
        function getConfessionMeterTextAndColor(percentage) {
            if (percentage > 80) return { text: "æ…‹åº¦å¼·ç¡¬", colorClass: "confession-color-white" };
            if (percentage > 60) return { text: "æ•…ä½œé®å®š", colorClass: "confession-color-green" };
            if (percentage > 40) return { text: "ç•¥é¡¯å‹•æ–", colorClass: "confession-color-blue" };
            if (percentage > 20) return { text: "å¿ƒè™›æ…Œäº‚", colorClass: "confession-color-pink" };
            if (percentage > 0) return { text: "ç€•è‡¨å´©æ½°", colorClass: "confession-color-red" };
            return { text: "å·²ç„¶èªç½ª", colorClass: "confession-color-purple" };
        }


        async function initializeFirebaseAndUser() {
            return new Promise(async (resolve, reject) => {
                try {
                    await setPersistence(auth, browserLocalPersistence);
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        console.log("å˜—è©¦ä½¿ç”¨è‡ªè¨‚ä»¤ç‰Œç™»å…¥ (Canvas ç’°å¢ƒ)ã€‚");
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        console.log("ç„¡è‡ªè¨‚ä»¤ç‰Œï¼Œå˜—è©¦åŒ¿åç™»å…¥ (GitHub Pages / ç¨ç«‹åŸ·è¡Œ)ã€‚");
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("åˆå§‹åŒ–æœŸé–“çš„èªè­‰éŒ¯èª¤:", error);
                    if (!auth.currentUser) {
                        try {
                            console.warn("ç”±æ–¼å…ˆå‰çš„èªè­‰éŒ¯èª¤ï¼Œå›é€€åˆ°åŒ¿åç™»å…¥ã€‚");
                            await signInAnonymously(auth);
                        } catch (anonError) {
                            console.error("åš´é‡éŒ¯èª¤ï¼šåŒ¿åç™»å…¥ä¹Ÿå¤±æ•—:", anonError);
                            if(userIdDisplayEl) userIdDisplayEl.textContent = "èªè­‰å¤±æ•—";
                            return reject("Firebase Auth failed");
                        }
                    }
                }

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        if(userIdDisplayEl) userIdDisplayEl.textContent = userId.substring(0,8) + "...";
                        console.log("ä½¿ç”¨è€…å·²èªè­‰/æœƒè©±å·²é–‹å§‹ã€‚UID:", userId);
                    } else {
                        // Fallback for local user if auth fails completely, though less likely now
                        userId = `local_user_${crypto.randomUUID().substring(0,8)}`;
                        if(userIdDisplayEl) userIdDisplayEl.textContent = "æœ¬æ©Ÿç”¨æˆ¶";
                        console.warn("ç„¡å·²èªè­‰ä½¿ç”¨è€…ï¼ŒéŠæˆ²å°‡ä»¥æœ¬æ©Ÿç”¨æˆ¶IDé‹è¡Œã€‚");
                    }
                    resolve(userId);
                });
            });
        }


        async function loadOrCreateNewGame() {
            if(initialLoadingOverlay) initialLoadingOverlay.style.display = 'flex';
            if(gameMainAreaEl) gameMainAreaEl.style.display = 'none';
            if(initialLoadingMessageEl) initialLoadingMessageEl.textContent = "æ­£åœ¨é€£æ¥ä¼ºæœå™¨ä¸¦å‰µå»ºæ–°éŠæˆ²...";

            try {
                const userAuthId = await initializeFirebaseAndUser(); // Ensure user ID is available

                const response = await fetch(`${BACKEND_URL}/game/new`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId: userAuthId }) // Send Firebase UID to backend
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `ä¼ºæœå™¨éŒ¯èª¤: ${response.status}`);
                }
                gameState = await response.json();
                currentGameId = gameState.gameId; // Store the game ID from backend

                if(initialLoadingMessageEl) initialLoadingMessageEl.textContent = "éŠæˆ²è³‡æ–™è¼‰å…¥å®Œæˆï¼";
                updateUI(gameState);

                if(initialLoadingOverlay) initialLoadingOverlay.style.display = 'none';
                if(gameMainAreaEl) gameMainAreaEl.style.display = 'flex';
                if(introModal) introModal.classList.remove('hidden');

            } catch (error) {
                console.error("å‰µå»ºæ–°éŠæˆ²å¤±æ•—:", error);
                if(initialLoadingMessageEl) initialLoadingMessageEl.textContent = `éŒ¯èª¤: ${error.message}. è«‹ç¨å¾Œå†è©¦ã€‚`;
                // Optionally, disable game interactions or show a retry button
            }
        }

        function updateUI(state) {
            if (!state) {
                console.warn("updateUI called with null or undefined state.");
                return;
            }
            gameState = state; // Update global frontend state

            if(roundCountHeaderEl) roundCountHeaderEl.textContent = state.round ?? '0';

            const meterInfo = getConfessionMeterTextAndColor(state.confessionMeter ?? 100);
            if(confessionMeterTextCardEl) {
                confessionMeterTextCardEl.textContent = meterInfo.text;
                confessionMeterTextCardEl.className = 'confession-color-white'; // Reset classes
                confessionMeterTextCardEl.classList.add(meterInfo.colorClass);
            }

            if (state.suspect) {
                const suspect = state.suspect;
                if(suspectStatusNameEl) suspectStatusNameEl.textContent = suspect.name ?? "è®€å–ä¸­...";
                if(heartRateEl) heartRateEl.textContent = suspect.heartRate ?? "N/A";
                if(bloodPressureEl) bloodPressureEl.textContent = suspect.bloodPressure ?? "N/A";
                if(facialExpressionEl) facialExpressionEl.textContent = suspect.facialExpression ?? "è®€å–ä¸­...";
                if(bodyLanguageEl) bodyLanguageEl.textContent = suspect.bodyLanguage ?? "è®€å–ä¸­...";
                if(voiceToneEl) voiceToneEl.textContent = suspect.voiceTone ?? "è®€å–ä¸­...";

                if(suspectNameModalEl) suspectNameModalEl.textContent = suspect.name ?? "N/A";
                if(ageModalEl) ageModalEl.textContent = suspect.age ?? "N/A";
                if(genderModalEl) genderModalEl.textContent = suspect.gender ?? "N/A";
                if(dobModalEl) dobModalEl.textContent = suspect.dob ?? "N/A";
                if(zodiacModalEl) zodiacModalEl.textContent = suspect.zodiac ?? "N/A";
                if(bloodTypeModalEl) bloodTypeModalEl.textContent = suspect.bloodType ?? "N/A";
                if(educationModalEl) educationModalEl.textContent = suspect.education ?? "N/A";
                if(birthplaceModalEl) birthplaceModalEl.textContent = suspect.birthplace ?? "N/A";
                if(occupationModalEl) occupationModalEl.textContent = suspect.occupation ?? "N/A";
                if(healthStatusModalEl) healthStatusModalEl.textContent = suspect.healthStatus ?? "N/A";
                if(mannerismModalEl) mannerismModalEl.textContent = suspect.mannerism ?? "ç„¡";
                if(personalityModalEl) personalityModalEl.textContent = suspect.personality ?? "è®€å–ä¸­...";
            }

            if (state.caseDetails) {
                const caseDetails = state.caseDetails;
                if(autopsyReportModalContentEl) autopsyReportModalContentEl.innerHTML = (caseDetails.autopsyReport ?? "è®€å–ä¸­...").replace(/##(.*?)##/g, '<span class="case-keyword" data-keyword="$1">$1</span>').replace(/\n/g, "<br>");
                if(evidenceListModalContentEl) evidenceListModalContentEl.innerHTML = (caseDetails.evidence ?? []).map(e => `<li data-id="${e.id}">${(e.text ?? "è®€å–ä¸­...").replace(/##(.*?)##/g, '<span class="case-keyword" data-keyword="$1">$1</span>')}</li>`).join('');
                if(doubtsListModalContentEl) doubtsListModalContentEl.innerHTML = (caseDetails.doubts ?? []).map(d => `<li data-id="${d.id}">${(d.text ?? "è®€å–ä¸­...").replace(/##(.*?)##/g, '<span class="case-keyword" data-keyword="$1">$1</span>')}</li>`).join('');
            }

            if(dialogueAreaEl) dialogueAreaEl.innerHTML = '';
            if (state.dialogueHistory && Array.isArray(state.dialogueHistory)) {
                state.dialogueHistory.forEach(msg => addMessageToDialogue(msg.speaker, msg.text, msg.tone));
            }

            // Update interrogation tip
            if(interrogationTipAreaEl && state.interrogationTip) {
                interrogationTipAreaEl.textContent = "â€»è²¼å¿ƒæç¤ºï¼š " + state.interrogationTip;
            }


            document.querySelectorAll('.case-keyword').forEach(el => {
                el.onclick = () => {
                    const keyword = el.dataset.keyword;
                    if(keywordModalTitle) keywordModalTitle.textContent = `ğŸ”‘ é—œæ–¼ã€Œ${keyword}ã€`;
                    fetchKeywordInfo(keyword); // Renamed from getKeywordInfo to avoid conflict if any global exists
                    if(keywordModal) keywordModal.classList.remove('hidden');
                };
            });

            if (state.gameOver) {
                if(gameOverTitle) gameOverTitle.textContent = (state.confessionMeter <= 0) ? "âš–ï¸ å¯©å•æˆåŠŸï¼" : "âš–ï¸ å¯©å•å¤±æ•—ï¼";
                if(totalRoundsEl) totalRoundsEl.textContent = state.round ?? '0';

                if(gameAnalysisContainerEl && typeof state.gameAnalysis === 'object' && state.gameAnalysis.interrogationStyle) {
                    gameAnalysisContainerEl.innerHTML = `
                        <p class="analysis-section-title">1. åµè¨Šå“¡å¯©å•é¢¨æ ¼åˆ†æ:</p>
                        <p class="analysis-section-content">${state.gameAnalysis.interrogationStyle}</p>
                        <p class="analysis-section-title">2. èˆ‡å«ŒçŠ¯é¬¥æ™ºéç¨‹æŠ€å·§åˆ†æ:</p>
                        <p class="analysis-section-content">${state.gameAnalysis.techniqueAnalysis}</p>
                        <p class="analysis-section-title">3. åˆ†æç©å®¶åœ¨ç¾å¯¦ä¸–ç•Œæ½›åœ¨äººæ ¼ç‰¹è³ª:</p>
                        <p class="analysis-section-content">${state.gameAnalysis.playerPersonalityTrait}</p>
                    `;
                    if(achievementBannerEl && achievementTitleEl && state.gameAnalysis.achievementTitle){
                        achievementTitleEl.textContent = state.gameAnalysis.achievementTitle;
                        achievementBannerEl.classList.remove('hidden');
                    } else if (achievementBannerEl) {
                        achievementBannerEl.classList.add('hidden');
                    }
                } else if (gameAnalysisTextEl) { // Fallback for string analysis
                    gameAnalysisTextEl.textContent = typeof state.gameAnalysis === 'string' ? state.gameAnalysis : "åˆ†æç”Ÿæˆå¤±æ•—æˆ–æ ¼å¼ä¸ç¬¦ã€‚";
                     if(achievementBannerEl) achievementBannerEl.classList.add('hidden');
                }

                if(gameOverModal) gameOverModal.classList.remove('hidden');
            } else {
                if(gameOverModal) gameOverModal.classList.add('hidden');
            }
        }

        function addMessageToDialogue(speaker, text, tone = null) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('dialogue-bubble');
            let messageContent = text;

            if (speaker === 'Player') {
                messageDiv.classList.add('player-bubble');
                // Backend now stores tone with player message, so we can use gameState.selectedTone if needed, or rely on history
                const displayTone = tone || gameState.selectedTone || "æœªçŸ¥";
                messageContent = `(èªæ°£ï¼š${displayTone}) ${text}`;
                switch (displayTone) {
                    case 'å¹³ç·©': messageDiv.classList.add('player-bubble-calm'); break;
                    case 'æ†¤æ€’': messageDiv.classList.add('player-bubble-angry'); break;
                    case 'æŒ‘é‡': messageDiv.classList.add('player-bubble-provocative'); break;
                }
            } else if (speaker === 'è­¦å®˜') {
                messageDiv.classList.add('officer-bubble');
                messageContent = `<strong>è­¦å®˜ï¼š</strong> ${text}`;
            } else { // AI/Suspect
                messageDiv.classList.add('ai-bubble');
            }

            const processedText = messageContent.replace(/@@(.*?)@@/g, '<span class="keyword" data-keyword="$1">$1</span>');
            messageDiv.innerHTML = processedText;

            if(dialogueAreaEl) {
                dialogueAreaEl.appendChild(messageDiv);
                dialogueAreaEl.scrollTop = dialogueAreaEl.scrollHeight;
            }

            messageDiv.querySelectorAll('.keyword').forEach(el => {
                el.onclick = () => {
                    const keyword = el.dataset.keyword;
                    if(keywordModalTitle) keywordModalTitle.textContent = `ğŸ”‘ é—œæ–¼ã€Œ${keyword}ã€`;
                    fetchKeywordInfo(keyword);
                    if(keywordModal) keywordModal.classList.remove('hidden');
                };
            });
        }
        
        async function fetchKeywordInfo(keyword) {
            if (!currentGameId) {
                console.error("éŠæˆ² ID æœªè¨­å®šï¼Œç„¡æ³•ç²å–é—œéµå­—è³‡è¨Šã€‚");
                if(keywordModalText) keywordModalText.textContent = "éŒ¯èª¤ï¼šéŠæˆ²æœªåˆå§‹åŒ–ã€‚";
                return;
            }

            if(keywordModalText) keywordModalText.style.display = 'none';
            if(keywordFolderLoaderEl) keywordFolderLoaderEl.classList.remove('hidden');

            // --- Loader Animation Logic (copied from original) ---
            const totalPages = 4;
            let currentPage = 0;
            if(keywordFolderPagesBarEl) keywordFolderPagesBarEl.innerHTML = '';
            function renderKeywordPagesBar() {
              let html = '';
              for (let i = 0; i < totalPages; i++) {
                html += `<div class="page-dot${i === currentPage ? ' active' : ''}"></div>`;
              }
              if(keywordFolderPagesBarEl) keywordFolderPagesBarEl.innerHTML = html;
            }
            function updateKeywordPage() {
              currentPage = (currentPage + 1) % totalPages;
              renderKeywordPagesBar();
              if(keywordFolderPageTextEl) keywordFolderPageTextEl.textContent = `ç¬¬ ${currentPage + 1} / ${totalPages} é ï¼Œæ­£åœ¨å‘ˆä¸Šä¸­â€¦`;
            }
            renderKeywordPagesBar();
            if(keywordFolderPageTextEl) keywordFolderPageTextEl.textContent = `ç¬¬ 1 / ${totalPages} é ï¼Œæ­£åœ¨å‘ˆä¸Šä¸­â€¦`;
            if (keywordPageTimer) clearInterval(keywordPageTimer);
            keywordPageTimer = setInterval(updateKeywordPage, 700);
            // --- End Loader Animation Logic ---

            try {
                const response = await fetch(`${BACKEND_URL}/game/${currentGameId}/keyword?keyword=${encodeURIComponent(keyword)}`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `ä¼ºæœå™¨éŒ¯èª¤: ${response.status}`);
                }
                const data = await response.json();
                if(keywordModalText) keywordModalText.textContent = data.information || `é—œæ–¼ã€Œ${keyword}ã€çš„è³‡è¨Šç›®å‰ç„¡æ³•å–å¾—ã€‚`;

            } catch (error) {
                console.error(`ç²å–é—œéµå­— "${keyword}" è³‡è¨Šå¤±æ•—:`, error);
                if(keywordModalText) keywordModalText.textContent = `ç„¡æ³•è¼‰å…¥é—œæ–¼ã€Œ${keyword}ã€çš„è³‡è¨Šï¼š${error.message}`;
            } finally {
                if (keywordPageTimer) clearInterval(keywordPageTimer);
                if(keywordFolderLoaderEl) keywordFolderLoaderEl.classList.add('hidden');
                if(keywordModalText) keywordModalText.style.display = 'block';
            }
        }

        async function handlePlayerTurn(isDemandConfession = false) {
            if (!currentGameId) {
                console.error("éŠæˆ² ID æœªè¨­å®šï¼Œç„¡æ³•åŸ·è¡Œç©å®¶å‹•ä½œã€‚");
                alert("éŒ¯èª¤ï¼šéŠæˆ²æœªæ­£ç¢ºåˆå§‹åŒ–ï¼Œè«‹é‡æ–°è¼‰å…¥ã€‚");
                return;
            }

            const playerMessage = playerInputEl.value.trim();
            if (!isDemandConfession && !playerMessage) return; // No message for non-confession demand

             // Special cheat code, now it will just send a specific message that backend might interpret
            if (!isDemandConfession && playerMessage === "88888888") {
                // We can either handle this purely frontend for testing, or send a special command
                // For now, let's assume backend handles it if it receives this specific message.
                // Or, if it was a frontend-only cheat:
                // gameState.confessionMeter = 0;
                // updateUI(gameState); // This would show meter at 0
                // await handleBackendConfession(); // A new function to tell backend player forced confession
                // return;
                // For now, let it pass to backend as a normal message, backend can have a cheat handler
            }


            sendButton.disabled = true;
            demandConfessionButton.disabled = true;
            if (isDemandConfession) {
                demandConfessionButton.innerHTML = '<div class="loading-spinner !w-4 !h-4 border-t-white mx-auto"></div>';
            } else {
                sendButton.innerHTML = '<div class="loading-spinner !w-5 !h-5 border-t-white"></div>';
            }
            showThinkingModal(isDemandConfession ? 'æ­£åœ¨è¦æ±‚å°æ–¹èªç½ª...' : 'AIæ­£åœ¨åˆ†ææ‚¨çš„è¼¸å…¥...');

            const currentTone = gameState.selectedTone || "å¹³ç·©"; // Get current tone from gameState

            const payload = {
                message: isDemandConfession ? "" : playerMessage, // No message needed if demanding confession from backend logic
                tone: isDemandConfession ? "æ†¤æ€’" : currentTone, // Demanding confession is usually angry
                isDemandConfession: isDemandConfession
            };

            try {
                const response = await fetch(`${BACKEND_URL}/game/${currentGameId}/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                     // If game already over, backend might return 400 with current game state
                    if (errorData.gameState && errorData.error === "éŠæˆ²å·²çµæŸ") {
                        console.warn("å˜—è©¦åœ¨å·²çµæŸçš„éŠæˆ²ä¸­åŸ·è¡Œå‹•ä½œã€‚");
                        updateUI(errorData.gameState); // Update UI to reflect it's over
                    } else {
                        throw new Error(errorData.error || `ä¼ºæœå™¨éŒ¯èª¤: ${response.status}`);
                    }
                } else {
                    const updatedGameState = await response.json();
                    updateUI(updatedGameState); // This will update global gameState and render UI
                }
                
                if (!isDemandConfession) playerInputEl.value = '';

            } catch (error) {
                console.error("ç©å®¶å›åˆè™•ç†å¤±æ•—:", error);
                alert(`æ“ä½œå¤±æ•—: ${error.message}`);
                // Restore UI elements if error
            } finally {
                hideThinkingModal();
                sendButton.disabled = false;
                demandConfessionButton.disabled = false;
                sendButton.innerHTML = 'ç™¼é€';
                demandConfessionButton.textContent = 'è¦æ±‚èªç½ª';
            }
        }
        
        function restartGame() {
            // Re-initialize by calling the main loading function
            loadOrCreateNewGame();
            if(gameOverModal) gameOverModal.classList.add('hidden');
        }

        // Event Listeners
        if(closeIntroModalButton) {
            closeIntroModalButton.addEventListener('click', () => {
                if(introModal) introModal.classList.add('hidden');
                if (backgroundMusicEl && backgroundMusicEl.paused) {
                    backgroundMusicEl.play().catch(e => console.error("Error playing music:", e));
                }
            });
        }
        if(sendButton) sendButton.addEventListener('click', () => handlePlayerTurn(false));
        if(demandConfessionButton) demandConfessionButton.addEventListener('click', () => handlePlayerTurn(true));
        
        if(closeGameOverModalButton) {
            closeGameOverModalButton.addEventListener('click', () => {
                if(gameOverModal) gameOverModal.classList.add('hidden');
            });
        }

        if(playerInputEl) playerInputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handlePlayerTurn(false);
            }
        });

        toneButtons.forEach(button => {
            button.addEventListener('click', () => {
                toneButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                if(gameState) gameState.selectedTone = button.dataset.tone; // Update selectedTone in frontend state
            });
        });
        if(showPersonalDetailsButton) showPersonalDetailsButton.addEventListener('click', () => personalDetailsModal.classList.remove('hidden'));
        if(showStorySummaryButton) showStorySummaryButton.addEventListener('click', () => storySummaryModal.classList.remove('hidden'));
        if(restartGameButton) restartGameButton.addEventListener('click', restartGame);

        // Initial load
        window.addEventListener('load', () => {
            loadOrCreateNewGame(); // This now handles Firebase auth and then fetches from backend
            if (backgroundMusicEl) {
                backgroundMusicEl.play().catch(e => {
                    console.log("Background music autoplay was blocked. Will attempt after user interaction.", e);
                });
            }
        });

    </script>
</body>
</html>